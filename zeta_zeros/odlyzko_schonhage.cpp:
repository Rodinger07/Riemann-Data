#include <vector>
#include <fftw3.h>
#include "acb.h"
#include "acb_dirichlet.h"

void odlyzko_schonhage_zeros(double t_start, double delta, int num_points, std::vector<double>& zeros) {
    fftw_complex *in, *out;
    fftw_plan plan;
    int n = num_points;
    
    in = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * n);
    out = (fftw_complex*)fftw_malloc(sizeof(fftw_complex) * n);
    plan = fftw_plan_dft_1d(n, in, out, FFTW_FORWARD, FFTW_ESTIMATE);
    
    // Precalcular valores zeta en puntos equidistantes
    #pragma omp parallel for
    for (int i = 0; i < n; i++) {
        double t = t_start + i * delta;
        acb_t s, z;
        acb_init(s);
        acb_init(z);
        
        acb_set_d_d(s, 0.5, t);
        acb_dirichlet_zeta(z, s, 1000);
        
        in[i][0] = arf_get_d(arb_midref(acb_realref(z)), ARF_RND_NEAR);
        in[i][1] = arf_get_d(arb_midref(acb_imagref(z)), ARF_RND_NEAR);
        
        acb_clear(s);
        acb_clear(z);
    }
    
    // FFT para acelerar bÃºsqueda de ceros
    fftw_execute(plan);
    
    // Detectar cambios de signo (simplificado)
    for (int i = 1; i < n; i++) {
        if (in[i-1][0] * in[i][0] < 0) {
            double zero = t_start + (i - 0.5) * delta;
            zeros.push_back(zero);
        }
    }
    
    fftw_destroy_plan(plan);
    fftw_free(in);
    fftw_free(out);
}

int main() {
    std::vector<double> zeros;
    double t_start = 1e6;
    double delta = 0.1;
    int num_points = 1000000;
    
    odlyzko_schonhage_zeros(t_start, delta, num_points, zeros);
    
    printf("Primeros 10 ceros cerca de 1e6:\n");
    for (int i = 0; i < 10 && i < zeros.size(); i++) {
        printf("Zero %d: %.10f\n", i+1, zeros[i]);
    }
    
    return 0;
}
